{"name":"Ruby-Chess","tagline":"Command Line Chess Written in Ruby","body":"## Ruby-Chess\r\nCommand Line Chess Written in Ruby\r\n\r\n![Chess Screenshot](https://cloud.githubusercontent.com/assets/1512282/12153051/b07bbd18-b46c-11e5-8478-368fda6b21af.png)\r\n\r\n### Logic\r\n* Piece.rb is the parent class to all piece Objects.\r\n* Each instance of Piece holds a reference to the Board class.\r\n* There are three child classes to Piece, SlidingPieces, JumpingPieces, and Pawns\r\n* SlidingPieces include: Queens, Bishops, and Rooks\r\n* JumpingPieces include: Kings and Knights\r\n* E.g. Knight < JumpingPiece < Piece\r\n* Pawns inherit directly from Piece\r\n* E.g. Pawn < Piece\r\n\r\n### Classes\r\n\r\n* Game - The game class is responsible for actually running the game. It holds the game loop #run which will rescue any MoveErrors. MoveErrors is an error class that inherits from StandardError, this way its easier to debug error messages or create your own.\r\n```ruby\r\n  def run\r\n    until checkmate?\r\n      begin\r\n      from, to = @graphic.get_inputs(@colors_turn)\r\n      @board.move(from, to, @colors_turn)\r\n      rescue MoveError\r\n      retry\r\n      end\r\n      @colors_turn = turn?\r\n      @graphic.display\r\n    end\r\n    puts \"GAME OVER CHECKMATE\"\r\n  end\r\n```\r\nThis is how we created the MoveError class\r\n```ruby\r\nclass MoveError < StandardError\r\nend\r\n```\r\n\r\n**Dependency Injection and the Game class**. The Game class takes two additional objects, Board and Graphic, you can see where we use them in #run above. The code below shows how our Game class is initialized. The instances of board and game class are created and then passed into the Game class's #new method. This is preferred to creating Board and Graphic inside the Game class #initialize. This is an example of Depenency Injection. The idea is to create your dependencies outside of the class that is dependent on them. Dependency Injection is an important part of good object oriented design.\r\n```ruby\r\n\r\nboard = Board.new(8)\r\ngraphic = Graphic.new(board)\r\n\r\ngame = Game.new(board, graphic)\r\ngame.run\r\n```\r\n\r\n* Piece - Holds logic all pieces share. Every piece can move on the board and we use the instance method #moves to find all of the moves for a particular piece. The #move_directions method is polymorphic. Each piece can move in slightly different directions I stored those directions in a hash, see below.\r\n\r\n```ruby\r\n  def moves\r\n    possible_moves = []\r\n    self.move_directions.each do |key, value|\r\n      possible_moves << valid_options(value)\r\n    end\r\n\r\n    possible_moves.flatten(1)\r\n  end\r\n```\r\nEach piece will have its own move_directions method.\r\n\r\n```ruby\r\n# Rook < SlidingPieces\r\n  def move_directions\r\n    { :up    => [-1,0], \r\n      :down  => [1,0],\r\n      :left  => [0,-1],\r\n      :right => [0,1],\r\n    }\r\n  end\r\n```\r\n\r\n* Board - The board class is responsible for building the board upon game initialization and moving the pieces. The #move method is the most important method of the class. To move a piece you must first locate the piece on the board and store it in the variable piece. Then we make sure the its a valid move, if the move is valid we mark the piece as moved and change the state of the board. Lastly we check to see if the piece can be promoted.\r\n\r\n```ruby\r\n  def move(from, to, colors_turn)\r\n    piece = @cell[from[0]][from[1]]\r\n    check_conditions(from, to, colors_turn, piece)\r\n    piece.mark\r\n    execute_move(from, to)\r\n    promote(piece) if piece.kinged_status == true\r\n  end\r\n```\r\n\r\n* Graphic - The graphic class is not very interesting. Its responsible for creating the graphics in the terminal. Since we use a the arrow keys to capture a users move selection, we must re-render the entire board each time the user pushes an arrow key. This needs the most amount of refactoring because the rendering can be slow if the user pushes the keys too fast. However, I think the much simpler UI is worth the slower rendering. In chess people spend most of their time thinking and very little time actually moving pieces around. For this reason I think the slower rendering is worth it for a better UI.\r\n\r\n* SlidingPieces & JumpingPieces - These classes are similar in a lot of ways. The only difference is that a sliding pieces travel distance can change depending on the state of the board. What I mean by that is a Queen (SlidingPiece) can travel the entire length of the board if her path is unobstructed. However, a King (JumpingPiece), is limited in the number of squares he can travel in the x and y directions. Kings can only move 1 space in all directions if unobstructed. So the SlidingPieces utilizes a while loop to continue accumulating possible moves, while the JumpingPieces class uses the predetermined moves that are held by each piece, like the Rook example above.\r\n\r\n* Pawns - Pawns are a bit different of a piece, so they do not inherit from SlidingPiece or JumpingPiece. This is because a pawn has a few special rules. They can only attack if the enemy is in a diagonal in-front of them. They can be \"promoted\" if they reach they other side of the board. Lastly pawns can move two spaces forward for the intial move but once they are moved they can only move 1 space forward. \r\n\r\n\r\n### Features\r\n* Arrow Keys for Move input\r\n* Colorized UI\r\n* Shows Available Moves\r\n* Warns player when they're in check\r\n* RSpec for test coverage\r\n* Object Oriented Design Features: Inheritance and Polymorphism\r\n\r\n\r\n### Up and running\r\n* gem install 'colorize'\r\n* ruby lib/game.rb","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}